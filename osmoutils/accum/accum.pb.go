// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: osmosis/accum/v1beta1/accum.proto

package accum

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// AccumulatorContent is the state-entry for the global accumulator.
// It contains the name of the global accumulator and the total value of
// shares belonging to it from all positions.
type AccumulatorContent struct {
	AccumValue  github_com_cosmos_cosmos_sdk_types.DecCoins `protobuf:"bytes,1,rep,name=accum_value,json=accumValue,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.DecCoins" json:"accum_value"`
	TotalShares cosmossdk_io_math.LegacyDec                 `protobuf:"bytes,2,opt,name=total_shares,json=totalShares,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"total_shares"`
}

func (m *AccumulatorContent) Reset()         { *m = AccumulatorContent{} }
func (m *AccumulatorContent) String() string { return proto.CompactTextString(m) }
func (*AccumulatorContent) ProtoMessage()    {}
func (*AccumulatorContent) Descriptor() ([]byte, []int) {
	return fileDescriptor_4866f7c74a169dc2, []int{0}
}
func (m *AccumulatorContent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccumulatorContent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccumulatorContent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccumulatorContent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccumulatorContent.Merge(m, src)
}
func (m *AccumulatorContent) XXX_Size() int {
	return m.Size()
}
func (m *AccumulatorContent) XXX_DiscardUnknown() {
	xxx_messageInfo_AccumulatorContent.DiscardUnknown(m)
}

var xxx_messageInfo_AccumulatorContent proto.InternalMessageInfo

func (m *AccumulatorContent) GetAccumValue() github_com_cosmos_cosmos_sdk_types.DecCoins {
	if m != nil {
		return m.AccumValue
	}
	return nil
}

type Options struct {
}

func (m *Options) Reset()         { *m = Options{} }
func (m *Options) String() string { return proto.CompactTextString(m) }
func (*Options) ProtoMessage()    {}
func (*Options) Descriptor() ([]byte, []int) {
	return fileDescriptor_4866f7c74a169dc2, []int{1}
}
func (m *Options) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Options) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Options.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Options) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Options.Merge(m, src)
}
func (m *Options) XXX_Size() int {
	return m.Size()
}
func (m *Options) XXX_DiscardUnknown() {
	xxx_messageInfo_Options.DiscardUnknown(m)
}

var xxx_messageInfo_Options proto.InternalMessageInfo

// Record corresponds to an individual position value belonging to the
// global accumulator.
type Record struct {
	// num_shares is the number of shares belonging to the position associated
	// with this record.
	NumShares cosmossdk_io_math.LegacyDec `protobuf:"bytes,1,opt,name=num_shares,json=numShares,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"num_shares"`
	// accum_value_per_share is the subset of coins per shar of the global
	// accumulator value that allows to infer how much a position is entitled to
	// per share that it owns.
	//
	// In the default case with no intervals, this value equals to the global
	// accumulator value at the time of the position creation, the last update or
	// reward claim.
	//
	// In the interval case such as concentrated liquidity, this value equals to
	// the global growth of rewards inside the interval during one of: the time of
	// the position creation, the last update or reward claim. Note, that
	// immediately prior to claiming or updating rewards, this value must be
	// updated to "the growth inside at the time of last update + the growth
	// outside at the time of the current block". This is so that the claiming
	// logic can subtract this updated value from the global accumulator value to
	// get the growth inside the interval from the time of last update up until
	// the current block time.
	AccumValuePerShare github_com_cosmos_cosmos_sdk_types.DecCoins `protobuf:"bytes,2,rep,name=accum_value_per_share,json=accumValuePerShare,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.DecCoins" json:"accum_value_per_share"`
	// unclaimed_rewards_total is the total amount of unclaimed rewards that the
	// position is entitled to. This value is updated whenever shares are added or
	// removed from an existing position. We also expose API for manually updating
	// this value for some custom use cases such as merging pre-existing positions
	// into a single one.
	UnclaimedRewardsTotal github_com_cosmos_cosmos_sdk_types.DecCoins `protobuf:"bytes,3,rep,name=unclaimed_rewards_total,json=unclaimedRewardsTotal,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.DecCoins" json:"unclaimed_rewards_total"`
	Options               *Options                                    `protobuf:"bytes,4,opt,name=options,proto3" json:"options,omitempty"`
}

func (m *Record) Reset()         { *m = Record{} }
func (m *Record) String() string { return proto.CompactTextString(m) }
func (*Record) ProtoMessage()    {}
func (*Record) Descriptor() ([]byte, []int) {
	return fileDescriptor_4866f7c74a169dc2, []int{2}
}
func (m *Record) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Record) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Record.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Record) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Record.Merge(m, src)
}
func (m *Record) XXX_Size() int {
	return m.Size()
}
func (m *Record) XXX_DiscardUnknown() {
	xxx_messageInfo_Record.DiscardUnknown(m)
}

var xxx_messageInfo_Record proto.InternalMessageInfo

func (m *Record) GetAccumValuePerShare() github_com_cosmos_cosmos_sdk_types.DecCoins {
	if m != nil {
		return m.AccumValuePerShare
	}
	return nil
}

func (m *Record) GetUnclaimedRewardsTotal() github_com_cosmos_cosmos_sdk_types.DecCoins {
	if m != nil {
		return m.UnclaimedRewardsTotal
	}
	return nil
}

func (m *Record) GetOptions() *Options {
	if m != nil {
		return m.Options
	}
	return nil
}

func init() {
	proto.RegisterType((*AccumulatorContent)(nil), "osmosis.accum.v1beta1.AccumulatorContent")
	proto.RegisterType((*Options)(nil), "osmosis.accum.v1beta1.Options")
	proto.RegisterType((*Record)(nil), "osmosis.accum.v1beta1.Record")
}

func init() { proto.RegisterFile("osmosis/accum/v1beta1/accum.proto", fileDescriptor_4866f7c74a169dc2) }

var fileDescriptor_4866f7c74a169dc2 = []byte{
	// 432 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x93, 0x3f, 0x6f, 0xd3, 0x40,
	0x18, 0xc6, 0x73, 0x0d, 0x6a, 0x95, 0x0b, 0xd3, 0x89, 0x08, 0xab, 0x20, 0x27, 0x84, 0x25, 0x12,
	0xea, 0x59, 0x4d, 0x16, 0x56, 0xd2, 0x8a, 0x09, 0x04, 0x32, 0x88, 0x81, 0xc5, 0x3a, 0x9f, 0x4f,
	0xc9, 0xa9, 0xf6, 0xbd, 0xd6, 0xfd, 0x09, 0xea, 0xce, 0xc2, 0xc6, 0xca, 0x57, 0xe0, 0x93, 0x74,
	0xcc, 0x88, 0x18, 0x0a, 0x4a, 0xbe, 0x08, 0xf2, 0x9d, 0x5d, 0x3a, 0x30, 0xb0, 0x74, 0xf2, 0xbd,
	0xf6, 0xf3, 0xfe, 0x9e, 0x57, 0x8f, 0xdf, 0xc3, 0x4f, 0xc0, 0x54, 0x60, 0xa4, 0x49, 0x18, 0xe7,
	0xae, 0x4a, 0x36, 0xa7, 0xb9, 0xb0, 0xec, 0x34, 0x54, 0xb4, 0xd6, 0x60, 0x81, 0x8c, 0x5a, 0x09,
	0x0d, 0x2f, 0x5b, 0xc9, 0xf1, 0x83, 0x15, 0xac, 0xc0, 0x2b, 0x92, 0xe6, 0x14, 0xc4, 0xc7, 0x31,
	0xf7, 0xea, 0x24, 0x67, 0x46, 0xdc, 0xd0, 0x38, 0x48, 0x15, 0xbe, 0x4f, 0xb7, 0x08, 0x93, 0x17,
	0x0d, 0xc7, 0x95, 0xcc, 0x82, 0x3e, 0x03, 0x65, 0x85, 0xb2, 0x44, 0xe3, 0xa1, 0xa7, 0x67, 0x1b,
	0x56, 0x3a, 0x11, 0xa1, 0x49, 0x7f, 0x36, 0x9c, 0x3f, 0xa6, 0x01, 0x46, 0x1b, 0x58, 0xe7, 0x4b,
	0xcf, 0x05, 0x3f, 0x03, 0xa9, 0x96, 0x8b, 0xab, 0xeb, 0x71, 0xef, 0xfb, 0xaf, 0xf1, 0xb3, 0x95,
	0xb4, 0x6b, 0x97, 0x53, 0x0e, 0x55, 0xd2, 0x9a, 0x87, 0xc7, 0x89, 0x29, 0x2e, 0x12, 0x7b, 0x59,
	0x0b, 0xd3, 0xf5, 0x98, 0x14, 0x7b, 0x97, 0x0f, 0x8d, 0x09, 0x79, 0x89, 0xef, 0x5b, 0xb0, 0xac,
	0xcc, 0xcc, 0x9a, 0x69, 0x61, 0xa2, 0x83, 0x09, 0x9a, 0x0d, 0x96, 0x4f, 0x1b, 0xec, 0xcf, 0xeb,
	0xf1, 0xa3, 0x00, 0x31, 0xc5, 0x05, 0x95, 0x90, 0x54, 0xcc, 0xae, 0xe9, 0x2b, 0xb1, 0x62, 0xfc,
	0xf2, 0x5c, 0xf0, 0x74, 0xe8, 0x1b, 0xdf, 0xf9, 0xbe, 0xe9, 0x00, 0x1f, 0xbd, 0xa9, 0xad, 0x04,
	0x65, 0xa6, 0xdf, 0xfa, 0xf8, 0x30, 0x15, 0x1c, 0x74, 0x41, 0x96, 0x18, 0x2b, 0x57, 0x75, 0x6c,
	0xf4, 0xff, 0xec, 0x81, 0x72, 0x55, 0x20, 0x93, 0xcf, 0x08, 0x8f, 0x6e, 0xc5, 0x92, 0xd5, 0x42,
	0x07, 0x60, 0x74, 0x70, 0x57, 0x01, 0x91, 0xbf, 0x01, 0xbd, 0x15, 0xda, 0xcf, 0x41, 0xbe, 0x20,
	0xfc, 0xd0, 0x29, 0x5e, 0x32, 0x59, 0x89, 0x22, 0xd3, 0xe2, 0x13, 0xd3, 0x85, 0xc9, 0x7c, 0x04,
	0x51, 0xff, 0xae, 0x06, 0x19, 0xdd, 0x38, 0xa6, 0xc1, 0xf0, 0x7d, 0xe3, 0x47, 0x9e, 0xe3, 0x23,
	0x08, 0x61, 0x47, 0xf7, 0x26, 0x68, 0x36, 0x9c, 0xc7, 0xf4, 0x9f, 0xeb, 0x49, 0xdb, 0x5f, 0x92,
	0x76, 0xf2, 0xe5, 0xeb, 0xab, 0x5d, 0x8c, 0xb6, 0xbb, 0x18, 0xfd, 0xde, 0xc5, 0xe8, 0xeb, 0x3e,
	0xee, 0x6d, 0xf7, 0x71, 0xef, 0xc7, 0x3e, 0xee, 0x7d, 0x5c, 0xdc, 0x9a, 0xab, 0x85, 0x9d, 0x94,
	0x2c, 0x37, 0x5d, 0x91, 0x6c, 0xe6, 0x73, 0x7f, 0x76, 0x56, 0x96, 0xed, 0x4d, 0xc9, 0x0f, 0xfd,
	0x3e, 0x2f, 0xfe, 0x04, 0x00, 0x00, 0xff, 0xff, 0x41, 0x14, 0xc8, 0x4b, 0x41, 0x03, 0x00, 0x00,
}

func (m *AccumulatorContent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccumulatorContent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccumulatorContent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.TotalShares.Size()
		i -= size
		if _, err := m.TotalShares.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintAccum(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.AccumValue) > 0 {
		for iNdEx := len(m.AccumValue) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AccumValue[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAccum(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Options) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Options) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Options) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Record) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Record) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Record) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Options != nil {
		{
			size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAccum(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.UnclaimedRewardsTotal) > 0 {
		for iNdEx := len(m.UnclaimedRewardsTotal) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UnclaimedRewardsTotal[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAccum(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.AccumValuePerShare) > 0 {
		for iNdEx := len(m.AccumValuePerShare) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AccumValuePerShare[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAccum(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size := m.NumShares.Size()
		i -= size
		if _, err := m.NumShares.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintAccum(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintAccum(dAtA []byte, offset int, v uint64) int {
	offset -= sovAccum(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AccumulatorContent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AccumValue) > 0 {
		for _, e := range m.AccumValue {
			l = e.Size()
			n += 1 + l + sovAccum(uint64(l))
		}
	}
	l = m.TotalShares.Size()
	n += 1 + l + sovAccum(uint64(l))
	return n
}

func (m *Options) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Record) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.NumShares.Size()
	n += 1 + l + sovAccum(uint64(l))
	if len(m.AccumValuePerShare) > 0 {
		for _, e := range m.AccumValuePerShare {
			l = e.Size()
			n += 1 + l + sovAccum(uint64(l))
		}
	}
	if len(m.UnclaimedRewardsTotal) > 0 {
		for _, e := range m.UnclaimedRewardsTotal {
			l = e.Size()
			n += 1 + l + sovAccum(uint64(l))
		}
	}
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovAccum(uint64(l))
	}
	return n
}

func sovAccum(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAccum(x uint64) (n int) {
	return sovAccum(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AccumulatorContent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccumulatorContent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccumulatorContent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccumValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccum
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAccum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccumValue = append(m.AccumValue, types.DecCoin{})
			if err := m.AccumValue[len(m.AccumValue)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalShares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalShares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAccum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Options) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Options: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Options: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAccum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAccum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Record) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Record: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Record: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumShares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NumShares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccumValuePerShare", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccum
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAccum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccumValuePerShare = append(m.AccumValuePerShare, types.DecCoin{})
			if err := m.AccumValuePerShare[len(m.AccumValuePerShare)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnclaimedRewardsTotal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccum
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAccum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnclaimedRewardsTotal = append(m.UnclaimedRewardsTotal, types.DecCoin{})
			if err := m.UnclaimedRewardsTotal[len(m.UnclaimedRewardsTotal)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccum
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAccum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &Options{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAccum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAccum(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAccum
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAccum
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAccum
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAccum
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAccum
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAccum
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAccum        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAccum          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAccum = fmt.Errorf("proto: unexpected end of group")
)
