name: "Auto Assign Reviewers"
on:
  pull_request:
    types:
      - opened
      - synchronize

jobs:
  assign_reviewers:
    runs-on: ubuntu-latest
    steps:
      - name: Assign reviewers based on modified files
        uses: actions/github-script@v5
        with:
          script: |
            const prAuthor = context.payload.pull_request.user.login;
            
            const rules = [
              { paths: ['app/wasm/**/*'], reviewers: ['nicolaslara', 'czarcas7ic'] },
              { paths: ['x/concentrated-liquidity/**/*'], reviewers: ['mattverse', 'czarcas7ic', 'p0mvn'] },
              { paths: ['x/downtime-detector/**/*'], reviewers: ['nicolaslara'] },
              { paths: ['x/epochs/**/*'], reviewers: ['mattverse', 'nicolaslara'] },
              { paths: ['x/gamm/**/*'], reviewers: ['mattverse', 'czarcas7ic', 'p0mvn'] },
              { paths: ['x/incentives/**/*'], reviewers: ['mattverse', 'p0mvn'] },
              { paths: ['x/lockup/**/*'], reviewers: ['mattverse', 'stackman27', 'czarcas7ic'] },
              { paths: ['x/mint/**/*'], reviewers: ['p0mvn'] },
              { paths: ['x/pool-incentives/**/*'], reviewers: ['czarcas7ic', 'p0mvn'] },
              { paths: ['x/poolmanager/**/*'], reviewers: ['mattverse', 'czarcas7ic', 'p0mvn'] },
              { paths: ['x/protorev/**/*'], reviewers: ['p0mvn'] },
              { paths: ['x/superfluid/**/*'], reviewers: ['mattverse', 'stackman27'] },
              { paths: ['x/tokenfactory/**/*'], reviewers: ['mattverse', 'nicolaslara', 'p0mvn'] },
              { paths: ['x/twap/**/*'], reviewers: ['nicolaslara', 'p0mvn'] },
              { paths: ['x/txfees/**/*'], reviewers: ['nicolaslara', 'p0mvn'] },
              { paths: ['x/valset-pref/**/*'], reviewers: ['mattverse', 'stackman27'] },
            ];

            async function getModifiedFiles(client, owner, repo, pull_number) {
              const options = client.rest.pulls.listFiles.endpoint.merge({ owner, repo, pull_number });
              const files = await client.paginate(options);
              return files.map(file => file.filename);
            }

            async function assignReviewers(client, owner, repo, pull_number, reviewers) {
              await client.rest.pulls.requestReviewers({
                owner,
                repo,
                pull_number,
                reviewers,
              });
            }

            function matchGlob(file, pattern) {
              const pathParts = file.split('/');
              const patternParts = pattern.split('/');

              for (let i = 0; i < pathParts.length && i < patternParts.length; i++) {
                if (patternParts[i] === '**') return true;
                if (patternParts[i] !== '*' && pathParts[i] !== patternParts[i]) return false;
              }

              return pathParts.length === patternParts.length;
            }

            (async () => {
              const { owner, repo, number: pull_number } = context.issue;
              const modifiedFiles = await getModifiedFiles(github, owner, repo, pull_number);
              const reviewersToAssign = new Set();

              for (const rule of rules) {
                for (const path of rule.paths) {
                  if (modifiedFiles.some(file => matchGlob(file, path))) {
                    rule.reviewers.forEach(reviewer => {
                      if (reviewer !== prAuthor) {
                        reviewersToAssign.add(reviewer);
                      }
                    });
                    break;
                  }
                }
              }

              if (reviewersToAssign.size > 0) {
                await assignReviewers(github, owner, repo, pull_number, Array.from(reviewersToAssign));
              }
            })();
          github-token: ${{ secrets.GITHUB_TOKEN }}
